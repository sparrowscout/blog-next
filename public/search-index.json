[{"slug":"reduce_re-rendering","date":"2023-11-02","timeStamp":1698883200000,"title":"리렌더링 줄이기","tags":[],"category":"","content":"1. 어디서 리렌더링이 발생하는지 확인하기 <br / 개발자 도구의 중단점(Breakpoints) 활용 ✏️ 개발자 도구의 Source 탭에서 Breakpoints(중단점)를 이용해서 어떤 순간에 어느 라인을 실행하는지 체크하자 🟠 Breakpoints:<br/ Breakpoints를 확인하고 싶은 함수 라인을 클릭하고나서 웹을 다시 실행시키거나 해당 함수가 실행되는 행동을 하면 함수 실행 타이밍에 브라우저 잠시 중단됨 <br/ 🟨 Data taps:<br/ Breakpoints에 대한 데이터를 볼 수 있는 탭들 <br/ 1. Watch: 오른쪽 + 아이콘을 통해 변수명을 입력하면 중단 시점의 변수에 담겨있는 값을 확인할 수 있음 <br/ 🟩 : 확인하고싶은 변수명 2. Breakpoints: 중단점을 한번에 확인할 수 있음, 중단점이 걸린 파일 별로 확인하고 중단점을 해제/등록할 수 있음 <br/ 🟦 : 중단점이 걸린 파일들 3. Scope: 스코프 내에 있는 모든 변수, 객체들의 값을 보여줌 <br/ 4. Call Stack: 중단 시점에 실행되는 함수의 call stack을 볼 수 있음.<br/ <br/ 리액트 환경일 경우 대부분 react hook으로 스택이 꽉 채워져서 리액트 개발할 때보다는 라이브러리, SDK 소스 확인할 때 Call Stack 탭이 유용했음. <br / 2. 왜 리렌더링이 발생하는지 확인하기 ✏️ 중단점을 걸어놓고 유저 플로우에 따라 서비스를 사용했을 때, '생각지도 못한' 함수가 실행되거나, '이 상황에 필요 없는' 함수가 실행되거나, '너무 자주' 실행되는 경우가 생긴다. 이제 IDE로 넘어와서 해당 함수가 가지고 있는 props, dependency array를 확인하자<br/ ① props, dependency Array 확인 리액트 컴포넌트의 라이프 사이클을 보면 (클래스 컴포넌트 기준) 크게 세 가지 타이밍 때 렌더링된다.<br/ 1. 컴포넌트 렌더링(생성) 시 2. 컴포넌트 업데이트 시 - props가 업데이트 됐을 때 - state가 업데이트 됐을 때 3. 컴포넌트 렌더링 제외 시 <br/ 주로 2번 사항 때문에 과도한 리렌더링이 발생하는데 props drilling이 있는 상태의 구조라면 부모 컴포넌트가 자신의 state를 업데이트 했을 때 자식 컴포넌트들이 모두 '불필요한' 렌더링을 겪게된다.<br/ 1. props를 전달할 때 '필요할 때' '근접한 거리의' 자식에게만 전달 하도록 하자<br/ 2. props drilling까지 감수해서 전달해야할 props라면 전역 상태 관리 툴을 사용하자. 좋은거 많다.<br/ 3. (본인의 state, 혹은 props가 업데이트 됐을 때 그 변화를 바라보고 함수를 실행시키는 hook인 useEffect를 사용했을 경우에는) useEffect의 dependency Array를 확인하고 불필요한 state가 배열에 들어있지 않은지 체크하고, 삭제할 건 삭제하자. (내 경우에는 이런 경우가 빈번했다.)<br/ 4. 처음부터 불필요한 state 구독이나 props 전달은 지양하자 ② useMemo 사용 state는 이전과 동일한 값을 넣었을 때는 리렌더링되지 않는다. state 이외에 동일한 계산을 매번 실행하거나, 동일한 값을 사용하는 함수에는 useMemo hook을 사용해주자 <br / - 추후에 좋은 방법들을 더 발견하면 추가하도록 하자."},{"slug":"BabylonJS","date":"2024-11-12","timeStamp":1731369600000,"title":"BabylonJS 공부하면서 헷갈렸던 개념 정리","tags":[],"category":"3D Rendering","content":"Animation과 Animatable의 차이 1. Animation Class used to store any kind of animation Animation 객체는 애니메이션 데이터만을 정의하는 객체입니다. 위치, 회전, 크기 등 특정 속성에 대해 프레임별로 값을 정의하여 시간 경과에 따라 값을 변경하는 방법을 설정합니다. 즉, 애니메이션 동작의 청사진이라고 볼 수 있습니다. 📎 babylon.js 공식문서 : Class Animation <br / 2. Animatable Class used to store an actual running animation Animatable 객체는 Animation이 실제로 실행될 때 생기는 인스턴스로, 실행 상태를 관리합니다. Babylon.js는 scene.beginAnimation을 호출하면 Animatable 객체를 생성합니다. 이 객체는 애니메이션의 시작, 중지, 재생 상태 등을 제어하며, 특정 대상(예: 메쉬, 카메라 등)에 대한 애니메이션을 제어하고 관리합니다. Animatable은 애니메이션이 대상에 적용된 상태를 의미하며, 실행 도중 중지할 수도 있고, 실행이 끝나면 메모리에서 사라질 수 있습니다. 📎 babylon.js 공식문서 : Class Animatable"},{"slug":"envFile","date":"2023-11-27","timeStamp":1701043200000,"title":"환경변수 파일 설정하기","tags":[],"category":"Next.js","content":"frontEnd, Next.js의 경우 Next.js는 아래의 3가지 방식으로 환경변수 기능을 지원함 1. process.env.NODE ENV : 구동환경 체크용 환경변수 2. .env 파일 : 구동 환경별 환경변수 적용 파일 3. NEXT PUBLIC : 브라우저에서 참조하기 위한 Prefix 4. process.env.NODE ENV : 구동환경 체크 변수 - Next.js는 자동으로 process.env.NODE ENV 변수를 생성하고, 구동 환경에 따라 아래의 3가지 값을 주입해 준다. 1) development : 개발 환경(next dev) 2) production : 배포 환경(next staart, next build) 3) test : 테스트 환경 backEnd, Nest.js의 경우"},{"slug":"HLS","date":"2023-08-24","timeStamp":1692835200000,"title":"HLS.js란?","tags":[],"category":"HLS.js","content":"HLS.js MSE를 통해, HLS 포맷으로 adaptive HTTP streaming을 제공하는 자바스크립트 라이브러리 <br / Media Source Extension(MSE) adpative streaming을 위해 제공되는 브라우저 표준 기술이다. <br / adpative streaming (↔︎ Progressive download) 사용자의 네트워크 상태(bandwidth)에 따라 대응하는 해상도의 동영상을 제공하는 기술이다. 기존 Progressive download방식에서는 한가지 해상도를 선택해 처음부터 끝까지 다운로드해서 영상을 제공하다보니 사용자의 네트워크 상황이 바뀌었을 때 지속적으로 낮은 해상도의 영상을 제공하게되거나, 긴 버퍼링을 겪는 문제가 있었다. 이 문제를 해결하기 위해 나온 방식이 adaptive streaming이다. adaptive streaming에서는 영상을 다양한 해상도로 인코딩해 segment로 잘게 쪼개서 저장해두고 네트워크 통신을 통해 사용자에게 segment단위로 데이터를 전달한다. <br / HLS adaptive HTTP streaming을 위한 Manifest(Playlist) 포맷 중 하나 <br / HLS.js가 master playlist를 받으면 → MSE에게 지속적으로 segment를 append master playlist parsing → <br/ media playlist parsing → <br/ segment load (예시에서는 .ts) → <br/ ts를 MSE가 받을 수 있는 mp4 형식으로 transmux → <br/ MSE buffer append → <br/ 브라우저에서 영상 렌더링 < 사용자 <br / master playlist (메인 m3u8): 해상도 별 media playlist들의 경로를 갖고있는 데이터 묶음 <br / media playlist (서브 m3u8): segment들의 경로를 갖고 있는 데이터 묶음 <br / 잘게 쪼개진 segment로 데이터를 제공하기때문에 사용자의 대역폭(bandwidth)에 따라 다음 데이터를 쉽게 교체할 수 있다. 사용자가 컨텐츠를 보는 중에 네트워크 상태가 나빠지면 더 낮은 bandwidth를 가지고 있는 media playlist의 segement들을 요청한다. 📎 hls.js demo page (playlist examples) <br/ 📎 웹 기술로 구현하는 Adaptive HTTP Streaming - NHN Cloud"},{"slug":"rendering-steps","date":"2025-01-01","timeStamp":1735689600000,"title":"영상이 브라우저에 렌더링되기까지 HLS가 하는 일","tags":[],"category":"HLS.js","content":"전체 흐름 클라이언트에서 hls 객체를 생성한 후부터 시작해서 브라우저에 렌더링되기까지의 단계를 정리하면 위와 같은 단계로 정리할 수 있습니다. <br / 마스터 플레이리스트 부르기 HLS.js에서는 main&sub playlist를 master&media playlist라고 부르고 있는데, 부르는 방식은 플레이어마다 다를 수 있습니다. master playlist에는 해상도와 bandwidth(대역폭)로 구분되어 있는 media playlist 경로들이 담겨있습니다. 담겨있는 media playlist들의 데이터를 정리하는 과정이 master playlist를 파싱하는 과정입니다.(영상, 오디오, 자막도 동일하게 담겨있을 수 있습니다.) hls는 처음에 사용자의 네트워크 상태로 몇 번째 해상도(레벨,트랙)의 media playlist를 재생할지 결정하고 해당 경로로 media playlist를 로드합니다. <br / 미디어 플레이리스트 부르기 media playlist에는 segment(\\ .m4s)경로들과 segment 각각의 정보들이 담겨있습니다. hls에서는 이 segment들을 순서대로 http 요청을 통해 로드하고, 재생합니다. 영상을 재생하면서 동시에 다음 segment들을 요청하기 위해서 media playlist가 파싱되고 난 후 hls 내에서 반복 함수 tick이 호출됩니다. <br / MSE가 파싱할 수 있게 segment transmux하기 http 요청을 통해 받은 segement들을 MSE가 파싱할 수 있는, 받아들일 수 있는 형태로 변형시키기 위해서 transmux 과정을 거칩니다. stream controller 클래스에서 transmux에 push하고, 완료되면 result를 반환받습니다. <br / transmux 완료한 데이터들을 MSE한테 던져주기 transmux가 완료된 데이터를 source buffer(MSE)에 순서대로 추가합니다. operation queue에 순서대로 들어가서 순서대로 브라우저에 렌더링됩니다. <br / 사용자의 네트워크 bandwidth를 의식하면서 위의 단계를 반복해서 영상을 재생하기! 사용자가 영상을 재생하는 도중에 네트워크 변동이 생긴다면 새로운 media playlist를 요청해야하고, 네트워크 변동이 없다면 내부에서 매트로놈처럼 움직이는 doTickIdle을 기점으로 segment 요청 → segment 로드 → segment transmux → source buffer append → 다음 segment 요청 → segment 로드 → ∙∙∙ 의 과정을 반복하면서 브라우저에 영상을 재생시킵니다."},{"slug":"test-config-in-hls","date":"2023-11-13","timeStamp":1699833600000,"title":"HLS.js 테스트 환경 설정하기","tags":[],"category":"HLS.js","content":"Test tools | role | plugin | | :--------------------- | :-------------------- | | 테스트러너 | Karma | | 테스트 프레임워크 | mocha, sinon-chai | | 테스트 리포터(log) | mocha | | 테스트 커버리지 | istanbul | | 크로스 브라우징 테스트 | karma-chrome-launcher | <br / Karma 설정하기 configuration HLS.js 내의 karma configuration <br/ Karma configuration 공식문서 <br / 테스트 프레임 워크 지정 | option | description | value | plugin | | :------------- | :-------------------------------- | :------------------------ | :-------------------------------- | | frameworks | karma가 사용하고 있는 frame works | ['mocha', 'sinon-chai'] | karma-mocha, karma-sinon-chai | <br / 테스트 대상 파일 지정 | option | description | value | plugin | | :------ | :----------------------- | :------------------------------------------------ | :----- | | files | 테스트 진행시킬 파일 | [{ pattern: 'tests/index.js', watched: false }] | | | exclude | 테스트에서 제외시킬 파일 | [] | | <br / 전처리기 설정 | option | description | value | plugin | | :----------------- | :---------------------------------------------------------------------- | :------------------------------------------------------------------------------------- | :-------------------------- | | preprocessors | 테스트 전처리기 | {'./tests/index.js': ['rollup']} <br/ : rollup을 사용해서 karma 테스트 전에 bundling | | | rollupPreprocessor | rollup preprocessor plugin의 설정값임. 기존 rollup bundle 설정과 동일함 | | karma-rollup-preprocessor | <br / 리포터 설정 | option | description | value | plugin | | :--------------- | :---------------------------------- | :------------------------------------------------------------------ | :--------------------------------------------------------------------- | | reporters | 리포터 설정 | ['mocha'] \\| ['mocha','coverage'] | karma-mocha-reporter, | | colors | 리포터(로그) 출력 시 색상 출력 여부 | true | | | coverageReporter | 커버리지 리포터 설정 | {reporters: []} \\| {reporters: [{ type: 'html', subdir: '.' }]} | rollup-plugin-istanbul<br/ : (rollup 전처리기와 함께 사용하고 있음) | <br / 테스트 브라우저 설정 | option | description | value | plugin | | :---------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------- | :---------------------- | | port | 웹 서버 포트 (Will be used as the port when launching browsers) | 9876 | | | browers | 테스트가 실행될 브라우저, karma가 실행되면 웹서버 포트에서 실행되고, karma가 종료되면 브라우저도 종료됨. (A list of browsers to launch and capture) | ['ChromeHeadless'] | karma-chrome-launcher | | singleRun | true일 시, karma는 모든 브라우저를 캡처, 모든 테스트를 실행시키고 모든 테스트를 패스하면 0, 하나라도 실패 시 1로 exit 됩니다. (Continuous Integration mode) | true | | | concurrency | 동시에 실행시킬 브라우저의 수 | 1 | |"},{"slug":"build-time-test","date":"2023-11-07","timeStamp":1699315200000,"title":"Build Time Test","tags":[],"category":"SDK","content":"SDK 패키징을 위해 번들러 툴과 컴파일 툴을 비교했습니다. 동일한 요구사항 내에서 번들러들끼리 비교한 이후, 제일 빠른 툴과 제일 느린 툴의 loader, plugin 등을 변경해서 환경 안에서 최적의 방식을 찾아내려고 했습니다. 🐱 github repository 번들러 목록 1. rollUp : HLS.js가 사용하고 있는 번들러, 라이브러리 패키징에 적절한 툴 2. webPack : 클래식이라고 생각되어서 목록에 넣음 3. ESBuild : LATEST이기도하고, 굉장히 빠르다고 들어서 비교군에 넣음 <br / 번들 요구사항 1. input : index.ts <br/ output : index.cjs(UMD), index.js(ESM), index.d.ts Typescript로 작성된 원본 소스 1개로 node 기반 모듈과 브라우저 기반 모듈을 포괄적으로 지원 하기 위해 UMD, ESM 라이브러리로 번들 + 타입스크립트 사용자를 지원하기 위해 .d.ts 파일 emit 2. minify: true UMD와 ESM을 선택한 이유? Javascript module 1. CommonJS : 맨 처음 자바스크립트를 웹 이외 환경, node 기반에서 사용하려고 했고, 모듈화를 맨 처음 시작함. 자바스크립트 V8엔진 이후에 CommonJS 모듈 발표함. 서버사이드 환경에 더 적합함. 2. AMD : CommonJS보다 브라우저 환경에 더 적합함. 3. UMD : CommonJS와 AMD를 동시에 호환하기 위해 만들어짐. 사용자의 모듈 로더를 확인해서 CommonJS, AMD, Window 방식으로 분기함 4. ESM : ECMAScript Module. 자바스크립트 ES6에서부터 사용 가능한 모듈 <br / 📚 → 라이브러리 패키징을 위한 빌드 테스트였기 때문에, 사용자의 환경을 최대한 포괄하기 위해 다양한 스펙트럼의 모듈을 제공하기위해서 UMD와 ESM을 선택함 <br / 테스트 환경 1. macOS Ventura 13.5.1 <br / 테스트 방식 1. 각 비교군 번들 5회 실행, 최장 시간과 최저 시간을 제외하고 빌드 시간의 산술평균 비교 1. script에 대한 총 시간을 구하기 위해서 yarn 명령어 사용 1. WebPack, RollUp은 빌드 완료 시 측정된 시간 log가 내장되어있는데 ESBuild는 아니었음. <br/ 그래서 build.onEnd((result) = {}) build.onStart(() = {}) API 사용 <br/ metafile:true config로 각각 파일 별 빌드 시작 시점과 종료 시점 구함 <br / 번들러 테스트 결과 1. yarn script : rm -rf dist && tsc --emitDeclarationOnly && build 2. average = 5회 실행 후, 최장 시간과 최저 시간을 제외하고 빌드 시간의 산술평균 ESBuild | | average | | --------- | ------------------------------------------------- | | cjs (umd) | <span style={{ color: ' 00c853' }} 5.67ms</span | | js (esm) | <span style={{ color: ' 00c853' }} 7.67ms</span | | total | <span style={{ color: ' 00c853' }} 2.35s </span | | | 1 | 2 | 3 | 4 | 5 | | -------- | :---: | :---: | :---: | :---: | :---: | | cjs(umd) | 6ms | 5ms | 5ms | 10ms | 6ms | | js(esm) | 7ms | 6ms | 7ms | 13ms | 9ms | | total | 2.24s | 2.27s | 2.29s | 2.50s | 2.76s | RollUp | | average | | --------- | -------------------------------------------------- | | cjs (umd) | <span style={{ color: ' 00c853' }} 709ms </span | | js (esm) | <span style={{ color: ' 00c853' }} 432.6ms</span | | total | <span style={{ color: ' 00c853' }} 3.49s </span | | | 1 | 2 | 3 | 4 | 5 | | -------- | :---: | :---: | :---: | :---: | :---: | | cjs(umd) | 710ms | 709ms | 704ms | 708ms | 716ms | | js(esm) | 431ms | 430ms | 434ms | 438ms | 433ms | | total | 3.46s | 3.48s | 3.49s | 3.50s | 3.53s | WebPack | | average | | --------- | ------------------------------------------------ | | cjs (umd) | <span style={{ color: ' 00c853' }} 412ms</span | | js (esm) | <span style={{ color: ' 00c853' }} 395ms</span | | total | <span style={{ color: ' 00c853' }} 3.07s </span | | | 1 | 2 | 3 | 4 | 5 | | -------- | :---: | :---: | :---: | :---: | :---: | | cjs(umd) | 415ms | 404ms | 410ms | 411ms | 431ms | | js(esm) | 379ms | 384ms | 391ms | 380ms | 409ms | | total | 2.97s | 3.02s | 3.02s | 3.17s | 3.86s | <br / 번들러 테스트 1차 결론 | ↑ | bundler | esm | umd | total | | --- | ------- | :-----: | :----: | :---: | | 1 | ESBuild | 7.67ms | 5.67ms | 2.76s | | 2 | WebPack | 395ms | 412ms | 3.07s | | 3 | RollUp | 432.6ms | 709ms | 3.49s | 1. ESBuild : <br/ ① UMD 번들러를 제공하고 있지 않아서, 다른 사용자가 만든 Plugin인 'umdWrapper'를 사용함 (github issue )<br/ ② TypeScript Complier가 내장되어 있어서, 별도의 transpile plugin 혹은 loader가 불필요함 2. Webpack : <br/ ① TypeScript complie을 위해서 'ts-loader'를 사용함 (공식문서 ) <br/ ② production mode로 빌드 시 minify & mangle 기본으로 실행됨 3. RollUp : <br/ ① TypeScript complie을 위해서 'typescript' plugin을 사용함 (공식문서 )<br/ ② minify를 위해서 'terser' plugin을 사용함 (타 라이브러리, 타 번들러 참고) → ESBuild WebPack RollUp 순으로 빠름. <br/ ESBuild RollUp Webpack 순서일 줄 알았는데 예상과 다르게 RollUp이 가장 느렸음. <br/ RollUp이 TypeScript transpile plugin과 minify plugin을 두개 다 사용하고 있어서 plugin 영향이 있는지 체크하고, 세 개 번들러 모두 번들러 각각에서 추천하고 있는, 혹은 각각 특징에 맞게 다른 plugin, loader를 사용하고 있기 때문에 최대한 통일해보는 과정이 필요할 것 같음. <br / RollUp이 가장 느렸던 이유 찾기 (Plugin) 1. typescript O, minify O (기존 configuration) | | average | | ----- | -------------------------------------------------- | | cjs | <span style={{ color: ' 00c853' }} 709ms </span | | js | <span style={{ color: ' 00c853' }} 432.6ms</span | | total | <span style={{ color: ' 00c853' }} 3.49s </span | | | 1 | 2 | 3 | 4 | 5 | | ----- | ----- | ----- | ----- | ----- | ----- | | cjs | 710ms | 709ms | 704ms | 708ms | 716ms | | js | 431ms | 430ms | 434ms | 438ms | 433ms | | total | 3.45s | 3.48s | 3.49s | 3.50s | 3.53s | 2. typescript X, minify X | | average | | ----- | ------------------------------------------------- | | cjs | <span style={{ color: ' 00c853' }} 21.3ms</span | | js | <span style={{ color: ' 00c853' }} 4ms</span | | total | <span style={{ color: ' 00c853' }} 0.47s </span | → 다른 plugin을 사용하지 않고, RollUp의 내장 config만을 사용해 JavaScript → JavaScript bundle만 실행했을 때 훨씬 빠른 결과 나옴 | | 1 | 2 | 3 | 4 | 5 | | ----- | ----- | ----- | ----- | ----- | ----- | | cjs | 22ms | 22ms | 21ms | 21ms | 21ms | | js | 4ms | 4ms | 4ms | 4ms | 5ms | | total | 0.48s | 0.47s | 0.47s | 0.47s | 0.47s | 3. typescript X, minify O | | average | | ----- | ------------------------------------------------ | | cjs | <span style={{ color: ' 00c853' }} 141ms</span | | js | <span style={{ color: ' 00c853' }} 112ms</span | | total | <span style={{ color: ' 00c853' }} 0.75s</span | | | 1 | 2 | 3 | 4 | 5 | | ----- | ----- | ----- | ----- | ----- | ----- | | cjs | 142ms | 141ms | 141ms | 141ms | 141ms | | js | 112ms | 112ms | 112ms | 111ms | 113ms | | total | 0.75s | 0.75s | 0.75s | 0.75s | 0.84s | 4. typescript O, minify X | | average | | ----- | -------------------------------------------------- | | cjs | <span style={{ color: ' 00c853' }} 592ms </span | | js | <span style={{ color: ' 00c853' }} 325.67ms</span | | total | <span style={{ color: ' 00c853' }} 1.66s</span | → typescript plugin을 사용하지 않고, minify 도구인 terser plugin을 사용한 3번 케이스와 비교해봤을 때, typescript plugin의 transpile 과정이 가장 많은 시간을 소비하고 있음 | | 1 | 2 | 3 | 4 | 5 | | ----- | ----- | ----- | ----- | ----- | ----- | | cjs | 596ms | 590ms | 585ms | 612ms | 592ms | | js | 337ms | 319ms | 327ms | 321ms | 329ms | | total | 1.68s | 1.65s | 1.65s | 1.67s | 1.66s | <br / plugin이랑 tsc를 하나씩 빼 봤을 때 @rollup/plugin-typescript 과정이 가장 오래걸려서 대체할 수 있는 transpiler로 babel을 사용해서 테스트 해보기로했다. <br / RollUp with Babel transpiler 1. babel O, minify X tsc O | | average | | ----- | --------------------------------------------------- | | cjs | <span style={{ color: ' 00c853' }} 179.67ms</span | | js | <span style={{ color: ' 00c853' }} 52ms</span | | total | <span style={{ color: ' 00c853' }} 2.40s </span | | | 1 | 2 | 3 | 4 | 5 | | ----- | ----- | ----- | ----- | ----- | ----- | | cjs | 179ms | 180ms | 177ms | 180ms | 181ms | | js | 17ms | 17ms | 18ms | 18ms | 17ms | | total | 2.56s | 2.69s | 2.31s | 2.32s | 2.33s | 1. babel O, minify O tsc O | | average | | ----- | -------------------------------------------------- | | cjs | <span style={{ color: ' 00c853' }} 274.3ms</span | | js | <span style={{ color: ' 00c853' }} 100.67ms</span | | total | <span style={{ color: ' 00c853' }} 2.54s </span | | | 1 | 2 | 3 | 4 | 5 | | ----- | ----- | ----- | ----- | ----- | ----- | | cjs | 287ms | 274ms | 274ms | 274ms | 275ms | | js | 101ms | 100ms | 101ms | 99ms | 101ms | | total | 2.59s | 2.52s | 2.52s | 2.51s | 2.68s | → Babel을 사용하니까 ts-loader를 사용한 WebPack보다 빠르게 나왔다. 그렇다면 통일된 transpiler로 비교해서 babel-loader를 사용한 webpack보다는? 1-1. WebPack with Babel | | average | | ----- | ------------------------------------------------ | | cjs | <span style={{ color: ' 00c853' }} 456ms</span | | js | <span style={{ color: ' 00c853' }} 436ms</span | | total | <span style={{ color: ' 00c853' }} 2.97s</span | | | 1 | 2 | 3 | 4 | 5 | | ----- | ------ | ------ | ------ | ------ | ------ | | cjs | 456 ms | 508 ms | 443 ms | 469 ms | 443 ms | | js | 435 ms | 482 ms | 423 ms | 448 ms | 425 ms | | total | 2.83s | 3.09s | 3.28s | 3.00s | 2.83s | babel-loader를 사용한 WebPack보다 빨랐다! <br/ 오히려 Webpack은 babel-loader를 사용하니까 ts-loader를 사용했을 때보다 느려졌다. RollUp은 더 빨라질 수 있을까? (complier 비교) 이제 Babel과 SWC를 비교해보려고 했는데<br/ RollUp이 제공하고 있는 Plugins, Packages, and Resources 문서↗︎에 SWC plugin이 없었다 ... 결론 1. ESBuild에 Typescript transpile이 내장되어있는건 TypeScript 환경에서 굉장히 장점인 것 같다. 2. TypeScript 환경인지, 다양한 개발 환경을 지원해야하는 라이브러리 개발인지, 어디까지 보수적으로 진행할지 프로젝트 by 프로젝트, 정책 by 정책이겠지만 어느정도 번들러가 탄생한 이유와 시점에 따라 적절한 번들러가 존재하는 것 같다."},{"slug":"modules","date":"2023-08-25","timeStamp":1692921600000,"title":"자바스크립트의 모듈에 대한 전반적인 개념","tags":[],"category":"SDK","content":"📎 You don't Know JS module, <br/ 📎 JavaScript 표준을 위한 움직임: CommonJS와 AMD 글을 요약 • 정리한 글입니다. <br / Modules 자바스크립트의 모듈 CommonJS a group with a goal of building up the JavaScript ecosystem for web servers, desktop and command line apps and in the browser. JavaScript를 브라우저 밖에서도(브라우저용 언어를 넘어 범용적으로) 사용하려고 조직한 자발적 워킹 그룹 → 범용적으로 사용하려면 모듈화 필요함 먼저 모듈은 자신만의 독립적인 실행 영역이 있어야 한다. 따라서 전역변수와 지역변수를 분리하는 것이 매우 중요하다. 서버사이드 JavaScript의 경우에는 파일마다 독립적인 파일 스코프가 있기 때문에 파일 하나에 모듈 하나를 작성하면 간단히 해결된다. V8 엔진 등장 → 서버사이드 JavaScript 환경을 전제로하는 CommonJS API 0.1 발표 하지만 이런 방식은 브라우저에서는 결정적인 단점이 있다. 필요한 모듈을 모두 내려받을 때까지 아무것도 할 수 없게 되는 것이다. 이 단점을 극복하려는 여러 방법이 CommonJS에서 논의되었지만, 결국 동적으로 < script 태그를 삽입하는 방법으로 가닥을 잡는다. < script 태그를 동적으로 삽입하는 방법은 JavaScript 로더들이 사용하는 가장 일반적인 방법이기도 하다. AMD(Asynchronous Module Definition) CommonJS와 비교해서, 브라우저 내에서의 실행에 중점을 둔 JavaScript 표준 API 라이브러리 제작 그룹, CommonJS에서 독립함 AMD에서는 비동기 모듈(필요한 모듈을 네트워크를 통해 내려받을 수 있도록 하는 것)에 대한 표준안을 다루고 있다. 대표적으로 꼽을 수 있는 것이 바로 define() 함수다. 브라우저 환경의 JavaScript는 파일 스코프가 따로 존재하지 않기 때문에 이 define() 함수로 파일 스코프의 역할을 대신한다. 즉, 일종의 네임스페이스 역할을 하여 모듈에서 사용하는 변수와 전역변수를 분리한다. 물론 define() 함수는 전역함수로 AMD 명세를 구현하는 서드파티 벤더가 모듈 로더에 구현해야 한다. 📌 필요한 파일이 모두 로컬 디스크에 있어 바로 불러 쓸 수 있는 상황, 즉 서버사이드에서는 CommonJS 명세가 AMD 방식보다 간결하다. 반면 필요한 파일을 네트워크를 통해 내려받아야 하는 브라우저와 같은 환경에서는 AMD가 CommonJS보다 더 유연한 방법을 제공한다. UMD(Universal Module Definition) UMD, or Universal Module Definition, is a module definition format that aims to be compatible with both CommonJS and AMD. It also allows you to export the module as a global variable that you can include in your application through a simple <script tag. It does this by wrapping the modules in a boilerplate that checks the environment to detect how the module is used, and produces the correct exported object. ❓ The UMD pattern typically attempts to offer compatibility with the most popular script loaders of the day (e.g RequireJS amongst others). ES Module ECMAScript 명세에 수록된 모듈 개념 (ES6)"},{"slug":"jenkins","date":"2023-11-07","timeStamp":1699315200000,"title":"Jenkins로 배포 자동화 설정하기 (npm package)","tags":[],"category":"DevOps","content":"Jenkins란? ✏️ 빌드, 테스트, 배포와 관련된 모든 종류의 작업을 자동화하는데 사용할 수 있는 독립형 오픈 소스 자동화 서버, 대부분의 CI/CD 배포 라이브러리들의 기본적인 구조는 Jenkins와 비슷합니다.<br/ <br / 프론트엔드 페이지를 배포하거나, 내부 SDK를 배포할 때 배포 단계를 자동화 시키고 싶어서 사용해보게 됐습니다. 사내 git 저장소로는 bitbucket을 사용하고 있어서 bitbucket pipeline을 사용할 수도 있지만 오히려 Jenkins로 설정하는게 추후 확장성에 좋을 것 같아서 Jenkins를 선택했습니다. <br/ <br / 배포 단계 그려보기 .png ) 젠킨스를 이용한 배포 단계를 크게보면 이렇습니다. 1. 개발자가 특정 저장소에 push 2. 저장소와 연결된 web hook이 해당 push 이벤트를 젠킨스에게 전달 3. push 이벤트를 전달받은 젠킨스가 작성된 스크립트에 따라 빌드, 테스트, 배포 진행 세부사항은 물론 저장소마다, 배포하려는 프로젝트마다 다르겠지만 이렇게 이해하고 다가가야 장벽이 좀 낮아지는 느낌이고, 어디에 뭘 연결해서 무슨 데이터를 보내는지 이해가 됩니다. <br / 연결하기 ✏️ 이벤트가 흘러가는 흐름을 따라 연결해줍니다. .png ) <br / 파이프라인 시나리오 작성하기 ✏️ 확장성이 좋다는 말은, 플러그인도 많고 옵션도 많고 이런저런 선택지가 많아서 그 중에 프로젝트에 맞는 선택을 해야한다는 뜻입니다. 개발자가 원하는 시나리오를 먼저 정확히 알고 있어야 스크립트 작성 중간에 파이프라인 종류를 바꿔야하거나 하는 불상사를 막을 수 있습니다.<br/ <br / 스크립트 작성하기 ✏️ push 이벤트를 받아서 젠킨스가 트리거된 후, 젠킨스가 실행시킬 파이프라인을 작성합니다. 파이프라인 문법에는 선언적 파이프라인과 스크립트 파이프라인이 있습니다. 구조는 비슷합니다. 저는 선언적 파이프라인 안에 스크립트 파이프라인을 작성했습니다. <br/ <br / - 스크립트 예시 1. git message와 npm version을 체크해서 배포하려고 고군분투 했던 JenkinsFile .... <br / 2. 처음에 젠킨스 설정 후 테스트하려고 작성했던 Jenkins file <br / 저장소에 push해서 테스트하기 ✏️ 설정한 저장소에 새 push commit을 넣어서 실제로 테스트해봅시다! <br/ <br / 새 push commit을 넣고 Jenkins에서 Stage 별로 진행되는 것을 UI로 확인해볼 수 있습니다. - Stage View <br/ 파이프라인에서 설정한 Stage 별 경과 시간과 실행한 step을 간결하게 확인할 수 있습니다. Stage 'for the fix branch'에서는 브랜치 명이 fix로 시작할 때만 step을 실행하도록 파이프라인을 작성했기 때문에 현재 브랜치인 PR-1에서는 건너뛴 모습입니다. .png ) - Scan Oragnization Folder Log (위의 UI에서 소비 시간을 클릭하면 log를 볼 수 있습니다) <br/ 처음에 연결하는 단계에서 잘못되거나, 스크립트가 잘못된 경우 로그를 확인하면서 따라가면 디버깅할 수 있습니다."},{"slug":"test","date":"2023-09-01","timeStamp":1693526400000,"title":"자바스크립트 테스트에 대한 전반적인 개념","tags":[],"category":"Test","content":"TEST - TOAST UI (2019.03.29) 글을 요약 • 정리한 글입니다. 테스트 <hr / 테스트의 종류 1. 단위테스트 2. 통합테스트 3. E2E(End to End) 테스트 <br / 자바스크립트 테스트 도구 테스트를 구동할 수 있는 환경을 제공하는 테스트러너 테스트 파일을 읽어들여 작성한 코드를 실행 하고, 그 결과를 특정한 형식으로 출력해준다. 테스트의 수행 결과는 리포터 를 지정해서 원하는 형태로 출력할 수 있다. 부가적으로 테스트 코드나 소스 코드가 변경된 경우 영향을 받는 테스트를 자동으로 재실행해주는 왓쳐 등의 기능도 제공한다. 테스트 러너는 크게 Karma와 같이 브라우저에서 직접 코드를 실행하는 러너와, Jest 와 같이 Node.js 환경에서 코드를 실행하는 러너로 나눌 수 있다. 이 중 Node.js 기반의 테스트 러너들은 굳이 러너의 샐항 환경과 코드의 실행 환경을 구분할 필요가 없기 때문에 대부분 테스트 프레임워크와 통합된 형태로 제공된다. 테스트 코드 작성을 위한 기반을 만들어주는 테스트 프레임워크 대표적인 테스트 프레임워크로는 Mocha, Jasmine, AVA 등이 있으며, 최근에는 Jest가 빠른 속도로 점유율을 높여가고 있다. 테스트를 좀 더 편리하게 작성할 수 있도록 도와주는 단언(assertion) 라이브러리, 테스트 더블 라이브러리 테스트 코드는 주로 테스트를 위한 초기화와 단언 으로 이루어지며, 단언은 개별 테스트가 통과하기 위한 조건을 명확하게 기술하기 위해 사용된다. 보통은 테스트 프레임워크에서 다양한 방식의 단언 API를 기본 제공하고 있으며, Mocha의 경우에만 Chai와 같은 별도의 단언 라이브러리를 사용하도록 권장하고 있다. 초기의 단언 라이브러리들은 JUnit과 유사한 방식의 API를 많이 따랐지만, 최근에 가장 많이 사용되는 Chai, Jasmine 등에서는 좀 더 자연어에 가까운 BDD(Behavior-driven development 방식의 API가 사용된다. 테스트 더블이란 실제 객체 대신 테스트를 위해 동작하는 객체를 말하며, 주로 분리된(isloated) 단위 테스트를 위해 외부 의존성을 임의로 주입하기 위해서 사용한다. 테스트 더블은 일반적으로 자바스크립트 객체 혹은 함수를 직접 변경하거나 생성하는 형태로 사용되며, Jest에서는 모듈 단위로 사용할 수 있는 기능도 제공한다. 테스트 실행 환경 브라우저 실제 브라우저를 실행해서 테스트 코드를 실행하는 방식을 의미하며, E2E 테스트 도구들을 제외한다면 현재로서는 Karma를 사용하는 것이 유일한 방법이라 할 수 있다. Karma는 테스트 러너의 역할만 하기 때문에 별도의 테스트 프레임워크가 추가로 필요하며, 보통 Jasmine을 사용하기를 권장한다. 커맨드 라인에서 Karma를 실행하면 먼저 자체 웹서버를 구동한 후 테스트 실행을 위한 HTML 페이지를 만들고, 작성된 테스트 코드 및 소스 코드 전부를 해당 페이지에 로드한다. 이후 브라우저를 직접 실행해서 해당 웹페이지에 접속하면 로드된 코드가 실행되고 테스트의 실행 결과는 브라우저 콘솔에 출력된다. Karma는 이 정보를 받아와 지정된 리포터를 사용해 결과를 정리한 후 커맨드 라인에 보여준다. 이 방식의 가장 큰 장점은 실제 브라우저 환경에서 테스트하기 때문에 브라우저의 모든 기능(네트워크 IO, 렌더링 엔진 등)을 활용해서 테스트할 수 있다는 점이다. 또한 Selenium 등의 도구를 사용하면 동일한 테스트 코드를 다양한 환경(운영체제, 브라우저) 테스트를 실행할 수 있기 때문에, 브라우저 호환성 및 기기 환경에 대한 테스트도 진행할 수 있다. 하지만 브라우저의 프로세스가 Node.js의 프로세스보다 무겁기 때문에 테스트의 초기 구동 속도가 더 느리다는 단점이 있다. 또한 브라우저라는 별도의 애플리케이션을 추가로 실행해야 하기 때문에 실행을 위한 브라우저 런처(launcher) 등을 추가로 설치해 주어야 하는 번거로움이 있으며, 크로스 브라우징 테스트 등을 위해서 별도의 환경을 구축하고 유지보수 하는 비용도 결코 무시할 수 없다. 이러한 단점을 극복하기 위해서 보통 개발 단계에서는 헤드리스 브라우저를 사용해서 빠른 피드백을 얻을 수 있도록 하고, 개발 완료 혹은 배포 시에만 CI 서버와 통합하여 크로스 브라우징 테스트를 하는 방식을 권장한다. 또한 Browser Stack이나 Sauce Lab 등의 외부 서비스를 사용하면 크로스 브라우징을 위한 환경을 직접 구축할 필요 없이 Karma와 손쉽게 연동하여 사용할 수 있다. Node.js Node.js 환경에서 테스트 코드를 실행하는 방식을 의미하며, 최근 가장 많이 쓰이는 도구는 Mocha와 Jest이다. 위에서 언급한 것처럼 테스트 러너와 테스트 프레임워크가 통합되어 있어 설치 및 실행이 비교적 간단하다. 이 방식의 가장 큰 장점은 역시 속도인데, Node.js의 프로세스가 브라우저의 프로세스에 비해 훨씬 가볍기 때문에 실행 속도가 빠르다. 또한 브라우저에서는 아직 모듈 단위의 테스트를 실행하기가 어려워 webpack 등의 번들러를 사용해야 하는 제약이 있는 반면 Node.js 환경에서는 개별 프로세스에서 원하는 모듈만 가져와서(import) 테스트할 수 있기 때문에 훨씬 간단하고 안전한 방식으로 테스트를 할 수 있다. 반면 이 방식의 중요한 단점은 브라우저의 모든 API를 제대로 활용할 수 없다는 것이다. Node.js에는 브라우저가 제공하는 DOM(Document Object Model)이나 BOM(Browser Object Model) 등의 API가 없기 때문이다. 이 문제를 해결하기 위해 jsdom과 같은 라이브러리를 사용해서 브라우저 환경을 가상으로 구현하는 방식을 사용하고 있지만, 실제 브라우저의 동작을 100% 구현하지는 못하기 때문에 많은 제약이 있다. 예를 들어 렌더링 엔진을 갖고 있지 않기 때문에 UI 요소의 레이아웃에 대한 테스트를 할 수 없고, 내비게이션 관련 동작도 사용할 수 없다. 그뿐만 아니라 브라우저에서 실행할 수가 없기 때문에 크로스 브라우징에 대한 테스트도 할 수 없다. 브라우저 vs Node.js 위의 설명을 보고도 아직 어떤 환경을 선택해야 할지 고민된다면 다음의 가이드를 따르기를 권장한다. 1. 크로스 브라우징 테스트가 \"반드시\" 필요한 경우 브라우저 환경을 사용한다. 2. 브라우저의 실제 동작(렌더링, 네트워크 IO, 내비게이션 등)에 대한 테스트가 필요한 경우 브라우저 환경을 사용한다. 3. 그 외의 경우 Node.js 환경을 사용한다. - 브라우저 : Karma + Jasmine - Node.js : Jest 유닛, 통합 테스트 도구 1. karma 1. 앞서 Jasmine으로 작성한 테스트 코드를 브라우저 환경에서 실행하기 위해서는 별도의 페이지를 생성하고, 소스 코드 및 테스트 코드 등을 모두 로드하는 등의 작업이 추가로 필요하다. 또한 테스트 결과를 확인하기 위해서는 UI를 추가하거나 브라우저 개발자 도구의 콘솔 창을 사용할 수밖에 없다. Karma는 브라우저 환경에서 테스트를 할 때 이러한 일련의 작업을 대신해 주는 도구로서, 아래와 같은 기능을 제공한다. - 로컬 웹서버를 구동한 후 테스트에 필요한 소스 코드 및 리소스를 모두 로드하는 HTML 페이지를 생성 한다. - 지정된 브라우저 프로세스를 자동으로 실행 한 후 앞서 생성한 웹페이지의 URL에 접속 한다. - 브라우저에서 실행된 결과를 받아와서 지정된 리포터를 사용해 다양한 형식으로 출력 한다. 2. 브라우저를 자동으로 실행하려면 각 브라우저에 맞는 런처를 별도로 설치해야 한다. 예를 들어 크롬 브라우저를 실행하기 위해서는 karma-chrome-launcher를 설치해야 한다. 크롬 외에도 다양한 브라우저 런처를 제공하며, 지원 브라우저의 목록은 공식 홈페이지에서 확인할 수 있다. 3. Karma는 프로젝트의 최상위 폴더에 있는 karma.config.js 파일로 설정 파일을 관리한다. 4. 테스트 커버리지 측정 : 작성한 테스트 코드의 커버리지는 Istanbul 라이브러리를 사용해 측정할 수 있다. Istanbul은 소스 코드를 분석해서 모든 줄마다 실행 횟수를 측정할 수 있는 코드를 삽입하는 방식으로 커버리지를 측정한다. 코드 실행 후에는 실행 결과를 HTML, LCOV, Cobertura 등의 다양한 포맷으로 출력해 주며, CI 서버에 연동해서 사용할 수도 있다. Istanbul을 커맨드 라인에서 직접 실행할 수도 있지만, 일반적으로는 테스트 러너가 플러그인 형태로 제공하는 것을 사용한다. Karma의 경우 karma-coverage 플러그인을 사용하면 istanbul을 사용한 커버리지 측정 결과를 손쉽게 확인할 수 있다. 1. 코드 커버리지 : 코드 커버리지란, 테스트 코드가 프로덕션 코드를 얼마나 실행했는지를 백분율로 나타내는 지표이다. 즉, 테스트 코드가 실제로 프로덕션 코드를 얼마나 몇 퍼센트 검증하고 있는지를 나타낸다. 코드 커버리지를 통해 현재 작성된 테스트 코드의 수가 충분한것인지 논의할 수 있다. 5. 크로스 브라우징 테스트 : 더 많은 기기를 지원해야 하는 프로젝트에서는 개발자 PC에서만 테스트를 하기가 불가능한 경우도 있다. 예를 들어 인터넷 익스플로러는 윈도우가 설치된 하나의 PC에 하나의 버전만 설치할 수 있기 때문에, 여러 버전의 인터넷 익스플로러를 테스트해야 하는 경우 여러 개의 PC 혹은 가상 머신을 사용할 수 밖에 없다. 이런 경우 karma와 Selenium WebDriver를 연결하여 사용하면 원격 PC를 사용해 테스트를 실행하고, 결과를 한 곳에 모아 출력할 수 있다. 간단히 설명하면 위의 예제에서 사용한 Chrome 런처 대신를 karma-webdriver-launcher로 변경해 주기만 하면 된다. 그러면 다음 그림과 같이 Hub의 역할을 하는 기기를 통해 연결된 원격 PC가 로컬 Karma 서버에 접근하도록 만들어 테스트를 실행하게 된다. 2. jasmine 1. Jasmine은 BDD 스타일의 단언 API를 사용하는 통합 테스트 프레임워크이며, Node.js와 브라우저 환경 모두에서 사용 가능하다. Mocha의 경우 단언 라이브러리는 Chai, 테스트 더블은 Sinon을 사용해야 하는 반면, Jasmine은 모든 기능을 통합해서 제공하기 때문에 라이브러리를 추가로 설치하고 설정할 필요 없이 쉽게 사용할 수 있다. 2. it() : 테스트 명세 3. expect() : 명세를 실행할 함수 내에서 검증을 위한 단언 4. describe() : 테스트를 그룹화함 중첩해서 사용 가능 5. beforeEach(), afterEach() : 각 테스트 명세가 실행되기 전 혹은 실행된 후에 필요한 로직 정의 6. spy : 자바스크립트에서 모의 객체를 사용할 때 가장 유용하게 사용되는 테스트 더블 중의 하나, 단순히 객체를 대신하는 역할을 할 뿐 아니라 실제 함수가 몇 번 호출되었는지, 어떤 인자를 넘겨주었는지 등의 정보를 모두 저장하고 있기 때문에 이러한 정보를 검증에 활용할 수 있다. 1. spyOn() 2. toHaveBeenCalledWith() 7. clock() : 타이머 제어 8. done() : 비동기 테스트 콜백함수 사용 / it((done)⇒done()) done()이 실행될 때 까지 테스트를 종료하지않고 대기함 9. fetchData() : 비동기 테스트 프로미스 사용 / 프로미스가 해결 될 때까지 테스트가 종료하지않고 대기함 10. async await : 비동기 테스트 async/await 사용 / it의 콜백함수로 async 함수를 직접 넘길 수 있음. 3. jest 1. Jest는 페이스북에서 만든 오픈소스 테스트 프레임워크이며, 최근 프론트엔드 개발에서 가장 활발하게 사용되는 테스트 도구이다. 꽤 오랜 기간 동안 개발되어 왔음에도 불구하고 한동안 관심을 받지 못하다가, 최근에 안정성 및 성능이 눈에 띄게 좋아지면서 많은 인기를 끌고 있다. Karma와는 다르게 Node.js 환경에서 실행되며, 내부적으로 Jasmine 스타일의 단언 API를 사용하기 때문에 기존에 Jasmine을 사용하고 있던 사용자들도 쉽게 적응할 수 있다. 1. 쉬운 설치 및 실행 1. jest.conf.js 파일을 생성해서 설정 옵션들을 설정 https://jestjs.io/docs/configuration 2. 쉬운 커버리지 측정 1. 커버리지를 확인하기 위해서는 커맨드 라인에서 실행할 때 --coverage 옵션만 추가하면 된다. 3. jsdom 내장 1. 앞서 언급했듯이 Node.js 환경에서는 브라우저에서 제공하는 DOM이나 window 객체의 API를 사용할 수 없다. 그래서 프론트엔드 코드를 테스트하기 위해서는 이러한 API를 가상으로 구현한 환경이 추가로 필요한데, 그중 가장 완성도가 높고 널리 쓰이는 라이브러리가 바로 jsdom이다. 하지만 jsdom은 라이브러리 형태로 제공되기 때문에 실제 사용하기 위해서는 테스트를 실행할 때마다 초기화 관련 코드를 실행해 주어야 하며, 이는 브라우저 환경에서 직접 실행하는 것에 비해 번거로울 수밖에 없다. 2. Jest에서는 jsdom을 내장하여 테스트 실행할 때마다 필요한 환경을 자동으로 설정해서 제공하기 때문에, 별다른 추가 작업 없이 마치 브라우저 환경인 것 처럼 테스트를 작성할 수 있다. 4. 스냅샷 테스트 1. 스냅샷 테스트는 주로 리액트의 가상 DOM 구조를 비교하기 위해 사용되는데, 테스트를 작성할 때 다음과 같이 toMatchSnapshot() 함수만을 사용하면 된다. 5. 테스트 파일 필터링 1. Jest는 테스트할 대상 파일을 구체적으로 지정할 수 있는 기능을 제공한다. 우선 Jest는 기본적으로 Git과 같은 버전 관리 도구와 연동하여 마지막 커밋 이후에 변경 사항이 있는 파일만을 테스트 대상에 포함한다. 이를 통해 이미 검증된 파일에 대해서 불필요한 테스트를 매번 실행하는 것을 방지할 수 있다. 6. 샌드박스 병렬 테스트 1. node.js 환경에서 테스트하기 때문에 기본적으로 빠름. 근데, 테스트를 순차적으로 실행하면서 개별 테스트마다 새로운 자식 프로세스를 생성하게되면 단일 프로세스에서 실행하는 것보다 느려지게 됨.이 문 제를 해결하기 위해 Jest는 다수의 프로세스를 병렬로 실행하는 방식을 사용해 속도를 향상시킴 E2E 테스트 도구 지금까지 살펴본 Karma, Jest 등의 도구들은 모두 단위 테스트나 통합 테스트를 위한 도구라고 볼 수 있다. 사실 E2E 테스트는 작성이 번거롭고 실행 속도가 느리며 통제된 환경에서 테스트를 할 수 없다는 단점 때문에 개발자들이 개발 과정에 사용하기에는 어려움이 많았다. 하지만 프론트엔드 개발의 경우 UI/UX 관련 기능을 실제 사용자 환경과 분리된 상태에서 테스트하기에는 한계가 있었기 때문에, 사용자의 관점에서 테스트를 할 수 있는 E2E 테스트에 대한 필요성이 꾸준히 요구되어 왔다. 1. Cypress 1. WebDriver와는 다르게 실제 애플리케이션과 테스트 코드를 동일한 브라우저에서 실행하는 방식을 취하고 있다. 이 방식은 HTTP 등을 사용한 프로세스 사이의 통신이 필요 없이 동일한 프로세스 내부에서 테스트를 실행하기 때문에 테스트를 훨씬 빠르고 안정적으로 실행할 수 있다. 또한 브라우저 기반의 GUI를 사용하여 테스트의 실행 상태를 확인하고 디버깅할 수 있는 다양한 편의 기능을 제공한다. 2. 예를 들면, 실행된 모든 테스트 명령과 각 명령이 실행될 때의 UI 상태를 스냅샷 형태로 모두 저장하고 있어, 특정 시점의 UI 상태를 눈으로 확인할 수 있다. 또한 전체 테스트 진행 과정을 동영상으로 저장하거나 테스트가 실패했을 때 자동으로 스크린샷을 남길 수 있어 테스트가 실패했을 때 원인을 파악하기가 매우 쉽다. 게다가 브라우저에서 실행되기 때문에 필요한 경우 크롬 개발자 도구를 사용해 디버깅을 할 수도 있다. 3. 하지만 브라우저 내부에서 실행되는 방식에는 단점 또한 존재하며, Cypress의 공식 문서에 잘 정리되어 있다."},{"slug":"afterParty","date":"2023-11-27","timeStamp":1701043200000,"title":"정보 접근성의 중요성과 필요성","tags":[],"category":"UIUX","content":"👨‍🏫 정보 접근성의 중요성과 필요성 11/7 화요일에 점핏에서 주최하고 삼성 강남에서 열린 '정보 접근성의 중요성과 필요성' 강연을 들을 수 있는 기회가 생겨서 다녀왔다. 사람인 프론트엔드 개발자로 일하고 계신 지성봉 개발자님의 강연이었다. UI/UX 디자인을 전공한 프론트엔드 개발자 입장에서 디자인에서 고려하는 정보 접근성과 개발자 입장에서 고려하는 정보 접근성이 어디가 어떻게 다를까 알고싶은 마음에 신청하게 됐다. 결론부터 말하자면 다르지 않았다. 그리고 프로덕트의 접근성을 고려하는 일이 디자이너나 개발자, 각자의 할일에 한정되어 있는 일이 아니라 기획, 디자인에서부터 개발 구현까지 프로덕트를 만드는 팀이 함께 생각해야하는 일이라고 느껴졌다. 강의 중간중간에, 얼마나 우리가 소수를 배제하고 있는지 살짝 꼬집어주는 부분들이 있어서 좋았다. 예를 들어서 ' 장애인이 우리 서비스를 사용할 리 없으니까 접근성을 고려하지 않아도 괜찮다.', '접근성 함양은 결국 장애인을 위한거니까 고려하지 않아도 괜찮다.' 라는 생각 자체가 차별적이고, 프로덕트의 사용자를 배제하고 있는 사고방식이라는 것을 알려주셨다. <br / '누군가는 사용할 수 없는 서비스'라는 것은 서비스의 굉장한 취약점이고, 그 자체로 버그다. 가장 취약한 사용층을 최소 기준으로 두면 거의 모든 사용자의 문제가 자연스럽게 해결 될 수 있다. 위의 두 문장이 웹의 접근성과 UX의 이유를 상당 부분 설명할 수 있는 문장인 것 같다. 지하철 엘리베이터는 원래 휠체어 사용자를 위해 설치된 시설물이지만, 실제로 사용하는 파이는 그 외가 더 크고, 전동 칫솔도, 누르는 방식으로 열리는 문 손잡이도 '원래 제품을 사용하는데 불편함이 있는 사람들을 위해 디자인, 설계 된' 제품들이지만 비장애인이 쓰기에도 훨씬 편하고 에너지가 덜 든다. 취약한 사용층을 타겟으로 UX 개선점을 찾는 것이 가장 효율적으로 UX를 개선하는 방향이고, 프로덕트를 만드는 맞는 방향이다. <br / 한국에서의 장애라는 단어는 많이 오염된 느낌이 있다. 단어 그 자체는 중립적이지만, 사회적인 논의와 접근이 이루어지지 않아서 장애에 대한 적절한 교육이 충분히 이루어지지도 않고, 재사회화 단계에서는 거의 전무하다. 색약도 장애고, 시력이 너무 안 좋은 것도 장애고, 손을 다쳐서 일시적으로 손을 못 쓰는 상황도 장애다. 서비스는 어떤 사람이던 사용할 수 있어야하고, 팀은 제공할 수 있는 최대한의 대체 정보, 대체 도구를 제공해야한다. 유니버셜 디자인과 같이 웹 접근성도 서비스, 프로덕트에 있는 장벽을 없애서 더 폭 넓은 사용자가 좋은 사용자 경험을 겪게 하는데에 핵심이 있다. 장애인 사용자를 고려해서 설계된 프로덕트는 비장애인 사용자의 UX도 함양시킬 수 있다. <br / 어떤 방식으로 접근성을 높여야하는지? 모범 사례들을 가져와도 우리 서비스에 맞지 않을 수 있다. 서비스와 상황에 맞게 접근성 원칙을 사용해야한다. POUR + 장애 유형별 대응 → 서비스 접근성 지침 <br / 접근성 원칙 POUR Perceivable 사용자가 제시되는 정보를 인식할 수 있어야한다는 원칙 <br/ 모든 정보가 텍스트 기반으로도 제공되어야함 <br/ Operable 사용자가 인터페이스를 조작할 수 있어야 함 <br/ 사용자가 조작할 수 없는 인터랙션이 없어야 함 <br/ - 키보드 만으로도 조작가능하게 제공, <br/ - 단순 클릭만으로 조작 가능 → 스와이프 UI와 클릭 버튼 병행 <br/ Understandable 사용자가 정보를 이해할 수 있어야 한다는 원칙 <br/ 움직이는 컨텐츠는 멈출 수 있게 제공 <br/ 직관적으로 알 수 있는 컨텐츠 제공 <br/ 사용자가 결과를 예측할 수 있는 인터랙션 제공 <br/ Robust 기술 발전에 따라 컨텐츠는 계속 접근할 수 있어야 한다는 원칙 <br / 장애의 종류 정보를 ‘인식’하는 감각에 대한 장애 약한 감각으로도 인식할 수 있도록 선명하게 제공 <br/ 다른 감각을 사용하여 인식할 수 있도록 제공 <br/ 인터랙션을 할 수 있는 움직임에 대한 장애 손이 아닌 다른 수단으로도 충분히 상호작용 할 수 있게 제공 <br/ 입에 스틱을 문 채로 드래그앤 드랍을 할 수 있을지? <br/ 정보 처리 과정의 결함을 유발하는 장애 낮은 이해도, 기억력 장애 <br/ 대표적인 예로 노화로 인한 장애 <br/ 광과민성 발작 장애 <br / 🧑‍💻 개발한다는 것 = 사용자가 사용하는 프로덕트를 만드는 일 강연을 듣고 며칠 뒤 KBO 시리즈가 개막했는데 사전 예매도 100% 온라인으로 진행되고, 취소표도 거의 온라인으로 거래되기 때문에 노인 야구 팬들이 소외되고 있다는 뉴스를 봤다. 편리함을 위해서 어떤 서비스를 만들고 혁신하는 속도에 비해 다양한 사용자들을 수용하려는 태도나 노력이 전반적으로 아쉽다."}]